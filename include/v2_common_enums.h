#ifndef V2_COMMON_ENUMS_H_
#define V2_COMMON_ENUMS_H_

#include "v2_common_types.h"
#include "v2_common_misc.h"
#include "v2_public_types.h"


typedef enum {
  //Note: the bit number in the enum represents R/G/B, and the bits can be inspected to derive what color components should be emited
  LED_OFF = 0x00,
  LED_RED = 0x01,
  LED_GREEN = 0x02,
  LED_YELLOW = 0x03,
  LED_BLUE = 0x04,
  LED_MAGENTA = 0x05,
  LED_CYAN = 0x06,
  LED_WHITE = 0x07,
} led_color_t;

typedef enum {
  FAKE_ERROR_DATA_MODE_NONE = 0,
  FAKE_ERROR_DATA_MODE_CONSTANT_VALUES,
  FAKE_ERROR_DATA_MODE_NAN_VALUES,
  FAKE_ERROR_DATA_MODE_INF_VALUES,
  FAKE_ERROR_DATA_MODE_NO_DATA_OUTPUT,
  FAKE_ERROR_DATA_MODE_OUT_OF_ORDER_DATA,
  FAKE_ERROR_DATA_MODE_SKIPPED_SAMPLE,

  FAKE_ERROR_DATA_MODE_LAST_ELEMENT
} fake_error_data_mode_t;

typedef enum {
  BUTTON_ANY_NO_EVENT,

  BUTTON_1_SINGLE_PRESS,
  BUTTON_1_HOLD_DOWN_3S,
  BUTTON_1_HOLD_DOWN_7S, //7-second threshold

  BUTTON_2_SINGLE_PRESS,
  BUTTON_2_HOLD_DOWN_3S,
  BUTTON_2_HOLD_DOWN_7S, //7-second threshold

  BUTTON_1_2_SINGLE_PRESS,
  BUTTON_1_2_HOLD_DOWN_3S,
  BUTTON_1_2_HOLD_DOWN_7S, //7-second threshold
} button_event_t;

/**
 * Enumerations used for USB control transfers to the AP during streaming.
 */
typedef enum {
  //Note: the start point for this enumeration is chosen so as to avoid duplicates with the SDU driver control functions and the MSD control functions.
  APDM_V2_CONTROL_TRANSFER_SET_OUTPUT_PIN = 0x40,
  APDM_V2_CONTROL_TRANSFER_CLEAR_OUTPUT_PIN,
  APDM_V2_CONTROL_TRANSFER_GET_OUTPUT_PIN,
  APDM_V2_CONTROL_TRANSFER_GET_INPUT_PIN,
  APDM_V2_CONTROL_TRANSFER_SET_MINIMUM_SYNC_VALUE,
  APDM_V2_CONTROL_TRANSFER_SET_MAX_LATENCY,

  APDM_V2_CONTROL_TRANSFER_USB_DATA_PURGE,

  APDM_V2_CONTROL_TRANSFER_LAST_ELEMENT
} apdm_v2_control_transfer_t;

/* CAN command types, used with the external sync box and smartsox. */
typedef enum {
    CAN_CMD_SET = 0,
    CAN_CMD_QUERY,
    CAN_CMD_PING,//2
    CAN_CMD_EDGE_DETECT,
    CAN_CMD_ERROR,//4
    CAN_CMD_HEARTBEAT,
    CAN_CMD_EXTERNAL_SENSOR_DATA,//6
    CAN_CMD_EXTERNAL_SENSOR_TIMESTAMP,//7
    //Do not go higher then 7, only 3 bits packed into the SID field

    CAN_CMD_LAST_ELEMENT,
} can_cmd_types_t;

/* CAN sensor types, used with the external smartsox. Can only currently have 8 of these!!! */
typedef enum {
    CAN_EXTERNAL_SENSOR_CONTROLLER = 0,
    CAN_EXTERNAL_SENSOR_ACCEL_MID_G,
    CAN_EXTERNAL_SENSOR_ACCEL_HIGH_G,
    CAN_EXTERNAL_SENSOR_GYRO,
    CAN_EXTERNAL_SENSOR_MAG,
    CAN_EXTERNAL_SENSOR_TEMPERATURE,

    CAN_EXTERNAL_SENSOR_LAST_ELEMENT
} external_sensor_type_t;

#if CAN_EXTERNAL_SENSOR_LAST_ELEMENT > 8
#error "Can only have 8 can external sensor types"
#endif

/*
 * External sensor reporting and commands.
 * Used with the external smartsox or other devices to interface w. monitor.
 * This is the first 16 bits of a CAN_EXTERNAL_SENSOR_CONTROLLER payload */
typedef enum {
  //need to have some sort of get ID and version command here
    EXTERNAL_CONTROLLER_CODE_CAN_ERRORS= 0, // Recieve Error Count (8), Transmit Error count (8), Chibios Error count (16)
    EXTERNAL_CONTROLLER_CODE_FW_DATE,
    EXTERNAL_CONTROLLER_CODE_FW_HASH,
    EXTERNAL_CONTROLLER_CODE_CAN_FRAMECOUNT,
    EXTERNAL_CONTROLLER_CODE_SSOX_SYSTEM_ERROR,
    EXTERNAL_CONTROLLER_CODE_REQUEST_CAN_ERROR,
    EXTERNAL_CONTROLLER_CODE_REQUEST_FW_DATE,
    EXTERNAL_CONTROLLER_CODE_REQUEST_FW_HASH,
    EXTERNAL_CONTROLLER_CODE_REQUEST_CAN_FRAMECOUNT,

    EXTERNAL_CONTROLLER_CODE_LAST_ELEMENT
} external_controller_code_type_t;

/* CAN SET COMMANDS, used with the external sync box and smartsox. */
typedef enum{
    CAN_SET_CMD_SET_OUTPUT_PIN = 0,
    CAN_SET_CMD_SET_LED_COLOR,

    CAN_SET_CMD_LAST_ELEMENT
} can_set_cmd_t;

/* CAN QUERY COMMANDS, used with the external sync box. */
typedef enum{
    CAN_QUERY_CMD_GET_OUTPUT_PIN = 0,
    CAN_QUERY_CMD_GET_INPUT_PIN,
    CAN_QUERY_CMD_GET_MODE,
    CAN_QUERY_CMD_GET_LED_COLOR,
    CAN_QUERY_CMD_GET_ERROR_STATE,
    CAN_QUERY_CMD_GET_LAST_ERROR_STATE,
    CAN_QUERY_CMD_GET_PCB_VERSION,
    CAN_QUERY_CMD_GET_UID_LOW,
    CAN_QUERY_CMD_GET_UID_MID,
    CAN_QUERY_CMD_GET_UID_HIGH,
    CAN_QUERY_CMD_GET_CAN_ERRORS,
    CAN_QUERY_CMD_GET_OUTPUT_ERRORS,
    CAN_QUERY_CMD_GET_INPUT_ERRORS,
    CAN_QUERY_CMD_GET_FIRMWARE_VERSION,

    CAN_QUERY_CMD_GET_LAST_ELEMENT
} can_query_cmd_t;


/* EDGE SETTINGS, used with the external sync box. */
typedef enum{
  CAN_EDGE_FALLING_EDGE = 0,
  CAN_EDGE_RISING_EDGE,
} can_edge_t;

typedef enum {
  CAN_SYNC_BOX_PIN_INPUT = 0,
  CAN_SYNC_BOX_PIN_OUTPUT
} can_sync_box_pin_t;

/* CAN PACKET STATUS, used with the external sync box and smartsox. */
typedef enum {
  CAN_PACKET_STATUS_CMD_SET_SUCCESS = 0,
  CAN_PACKET_STATUS_CMD_SET_FAILURE,
  CAN_PACKET_STATUS_CMD_QUERY_SUCCESS,
  CAN_PACKET_STATUS_CMD_QUERY_FAILURE,
  CAN_PACKET_STATUS_CMD_PING_SUCCESS,
  CAN_PACKET_STATUS_CMD_PING_FAILURE,
  CAN_PACKET_STATUS_CMD_RECORD_SUCCESS,
  CAN_PACKET_STATUS_CMD_RECORD_FAILURE,
  CAN_PACKET_STATUS_CMD_PACKET_DUPLICATE,
  CAN_PACKET_STATUS_CMD_PACKET_INVALID,
  CAN_PACKET_STATUS_CMD_UNHANDLED_CMD,
  CAN_PACKET_STATUS_CMD_HEARTBEAT_SUCCESS,
  CAN_PACKET_STATUS_CMD_HEARTBEAT_FAILURE,
} can_packet_status_t;



typedef enum {
  //Reference https://dev.apdm.com/trac/wiki/Names#HardwareID
  HARDWARE_ID_2_0 = 2048,
  HARDWARE_ID_2_1, //2049
  HARDWARE_ID_2_5, //2050
  HARDWARE_ID_2_6, //2051
  HARDWARE_ID_2_9, //2052 (Note: we never produced any 2.7 or 2.8 PCBs, hence no enum value)
  HARDWARE_ID_2_9_R1, //2053
  HARDWARE_ID_2_10, //2054

  HARDWARE_ID_LAST_ELEMENT
} hardware_id_t;



/**
 * Enumeration used to track device runtime statistics that get transmited over wireless to the AP and stored in the large per-device memory buffer on the AP.
 * WARNING: Adding elements to this enumeration will consume "large" amounts of memory in the APs per-device data structures.
 */
typedef enum {
  DEVICE_STATISTIC_NONE = 0,
  DEVICE_STATISTIC_RSSI,
  DEVICE_STATISTIC_CPU_PERCENT,
  DEVICE_STATISTIC_BATTERY_PERCENT,
  DEVICE_STATISTIC_BATTERY_VOLTAGE_MV,
  DEVICE_STATISTIC_BATTERY_TIME_TO_EMPTY_MINUTES,
  DEVICE_STATISTIC_BATTERY_REMAINING_CAPACITY_MAH,
  DEVICE_STATISTIC_BATTERY_FULL_CHARGE_CAPACITY_MAH,
  DEVICE_STATISTIC_FILTER_QUEUE_SAMPLES_PER_SECOND,
  DEVICE_STATISTIC_WIRELESS_QUEUE_SAMPLES_PER_SECOND,
  DEVICE_STATISTIC_STRUCTURE_SUM,
  DEVICE_STATISTIC_HARDWARE_ID,
  DEVICE_STATISTIC_MINIMUM_SYNC_VALUE_HIGH,
  DEVICE_STATISTIC_MINIMUM_SYNC_VALUE_LOW,
  DEVICE_STATISTIC_FIRMWARE_DATE,
  DEVICE_STATISTIC_SCHEMATIC_REVISION,
  //DEVICE_STATISTIC_BATTERY_DESIGN_CAPACITY_MAH,
  //DEVICE_STATISTIC_BATTERY_BQ_FW_VERSION,

  DEVICE_STATISTIC_LAST_ELEMENT
} apdm_device_statistic_t;

typedef enum {
  CONFIG_V2_FILTER_MODE_DEFAULT = 0,
  CONFIG_V2_FILTER_MODE_RAW_SENSOR_DATA
} config_v2_filter_mode_t;

typedef enum {
  CONFIG_V2_SD_BUFFERING_AUTO = 0,
  CONFIG_V2_SD_BUFFERING_ENABLED,
  CONFIG_V2_SD_BUFFERING_DISABLED,
} config_v2_sd_card_buffering_type_t;

typedef enum {
  CONFIG_V2_SI_SD_DATA_LOGGING_OFF = 0,
  CONFIG_V2_SI_SD_DATA_LOGGING_DEFAULT,
  CONFIG_V2_SI_SD_DATA_LOGGING_INDIVIDUAL_SENSORS,

  CONFIG_V2_SI_SD_DATA_LOGGING_LAST_ELEMENT
} config_v2_si_sd_data_logging_type_t;

typedef enum {
  CONFIG_V2_LED_MODE_OFF = 0,
  CONFIG_V2_LED_MODE_NORMAL,
} config_v2_led_mode_t;

typedef enum {
  WIRELESS_DOCKING_BEHAVIOR_DEFAULT = 0,
  WIRELESS_DOCKING_BEHAVIOR_ENABLE,

  WIRELESS_DOCKING_BEHAVIOR_LAST_ELEMENT
} wireless_docking_behavior_t;

/**
 * Used to define the external communications mode in the INI file of the opal.
 */
typedef enum {
  EXTERNAL_COMMUNICATIONS_MODE_NONE = 0,
  EXTERNAL_COMMUNICATIONS_MODE_UART,
  EXTERNAL_COMMUNICATIONS_MODE_CAN,
  EXTERNAL_COMMUNICATIONS_MODE_EXT_BUTTON,

  EXTERNAL_COMMUNICATIONS_MODE_LAST_ELEMENT
} external_communications_mode_t;

typedef enum {
  LOGGING_BEHAVIOR_DISABLE_WHILE_CHARGING = 0,
  LOGGING_BEHAVIOR_ENABLE_WHILE_CHARGING
} logging_behavior_t;

typedef enum {
  MONITOR_BUTTON_MODE_NONE = 0,
  MONITOR_BUTTON_MODE_EVENT_LOGGING
} monitor_button_mode_t;


typedef enum {
  RANGING_MODE_DISABLED = 0,
  RANGING_MODE_ANCHOR,
  RANGING_MODE_TAG
} ranging_mode_t;

/**
 * Various device data tracked at run time and queryable via USB "get" commands.
 */
typedef enum {
    DEVICE_DATA_CASE_ID = 0,
    DEVICE_DATA_SENSOR_ID,
    DEVICE_DATA_BUTTON_1,
    DEVICE_DATA_BUTTON_2,
    DEVICE_DATA_DIGITAL_INPUT,
    DEVICE_DATA_DIGITAL_OUTPUT,
    DEVICE_DATA_ANALOG_INPUT,
    DEVICE_DATA_SYNC_VALUE,
    DEVICE_DATA_EPOCH_MS_OFFSET,
    DEVICE_DATA_HARDWARE_ID,
    DEVICE_DATA_MODULE_ID,
    DEVICE_DATA_FIRMWARE_VERSION,
    DEVICE_DATA_USB_MILLIVOLTS,
    DEVICE_DATA_DISK_TOTAL_MEGS,
    DEVICE_DATA_DISK_USED_MEGS,
    DEVICE_DATA_STRUCTURE_SUM,
    DEVICE_DATA_DELETE_OLD_FILES,
    DEVICE_DATA_CONFIG_VALID,
    DEVICE_DATA_CALIBRATION_VERSION,
    DEVICE_DATA_BATTERY_MILLIVOLTS,
    DEVICE_DATA_BATTERY_CHARGE_STATUS,
    DEVICE_DATA_BOOTLOADER_VERSION,
    DEVICE_DATA_COMPILE_DATETIME,

    DEVICE_DATA_TEMPERATURE_C,
    DEVICE_DATA_BATTERY_CURRENT_MA,
    DEVICE_DATA_BATTERY_SOH,
    DEVICE_DATA_BATTERY_NOMINAL_AVAILABLE_CAPACITY_MAH,
    DEVICE_DATA_BATTERY_FULL_AVAILABLE_CAPACITY_MAH,
    DEVICE_DATA_BATTERY_CYCLE_COUNT,
    DEVICE_DATA_BATTERY_DESIGN_CAPACITY_MAH,
    DEVICE_DATA_BATTERY_BQ_FW_VERSION,

    DEVICE_DATA_EXTERNAL_CONTROLLER_FW_DATE,
    DEVICE_DATA_EXTERNAL_CONTROLLER_FW_HASH,

    DEVICE_DATA_LAST_ELEMENT
} apdm_device_data_t;


/**
 * Enumeration used to track error counts that occur at runtime in the firmware. These are distinct from error states in that they are generally
 * events that DO NOT PERSIST. error_state_t's are persisted/asserted/de-asserted, where as these are just counted.
 */
typedef enum {
  ERROR_NONE = 0,

  ERROR_STK_OVERFLOW,
  ERROR_FLUSH_CONFIG_FAIL,

  ERROR_EMMC_FF_WRITE,
  ERROR_EMMC_FF_READ,
  ERROR_EMMC_FF_READ_SIZE,
  ERROR_EMMC_FF_SEEK,
  ERROR_EMMC_FF_CLOSE,
  ERROR_EMMC_FF_OPEN,
  ERROR_EMMC_FF_MOUNT,
  ERROR_EMMC_FF_SYNC,

  ERROR_EMMC_WRITE_SAMPLE1,
  ERROR_EMMC_WRITE_SAMPLE2,
  ERROR_EMMC_WRITE_RAW,
  ERROR_EMMC_WRITE_HEADER,


  ERROR_FR_DISK_ERR,            /* (1) A hard error occurred in the low level disk I/O layer */
  ERROR_FR_INT_ERR,             /* (2) Assertion failed */
  ERROR_FR_NOT_READY,           /* (3) The physical drive cannot work */
  ERROR_FR_NO_FILE,             /* (4) Could not find the file */
  ERROR_FR_NO_PATH,             /* (5) Could not find the path */
  ERROR_FR_INVALID_NAME,        /* (6) The path name format is invalid */
  ERROR_FR_DENIED,              /* (7) Access denied due to prohibited access or directory full */
  ERROR_FR_EXIST,               /* (8) Access denied due to prohibited access */
  ERROR_FR_INVALID_OBJECT,      /* (9) The file/directory object is invalid */
  ERROR_FR_WRITE_PROTECTED,     /* (10) The physical drive is write protected */
  ERROR_FR_INVALID_DRIVE,       /* (11) The logical drive number is invalid */
  ERROR_FR_NOT_ENABLED,         /* (12) The volume has no work area */
  ERROR_FR_NO_FILESYSTEM,       /* (13) There is no valid FAT volume */
  ERROR_FR_MKFS_ABORTED,        /* (14) The f_mkfs() aborted due to any parameter error */
  ERROR_FR_TIMEOUT,             /* (15) Could not get a grant to access the volume within defined period */
  ERROR_FR_LOCKED,              /* (16) The operation is rejected according to the file sharing policy */
  ERROR_FR_NOT_ENOUGH_CORE,     /* (17) LFN working buffer could not be allocated */
  ERROR_FR_TOO_MANY_OPEN_FILES, /* (18) Number of open files > _FS_SHARE */
  ERROR_FR_INVALID_PARAMETER,    /* (19) Given parameter is invalid */


  ERROR_EMMC_FF_FORMAT_FAIL,

  ERROR_EMMC_FAILED_READ_RECORD,
  ERROR_EMMC_BAD_MAGIC1,
  ERROR_EMMC_PAYLOAD_TOO_BIG,
  ERROR_EMMC_BAD_STRUCT_TYPE,
  ERROR_EMMC_HEADER_RD_FAIL,
  ERROR_EMMC_DATA_HD_RD_FAIL,
  ERROR_EMMC_RAW_SAMP_RD_FAIL,
  ERROR_EMMC_SI_SAMP_RD_FAIL,
  ERROR_EMMC_SAMPLE_SIZE,
  ERROR_EMMC_PAD_WR_FAIL,
  ERROR_EMMC_CB_FAIL,

  ERROR_EMMC_MISSING_RUNSTATS,

  ERROR_INI_FILE_PARSE_FAIL,

  ERROR_USB_MSD_BLK_DEV_NOT_RDY,
  ERROR_USB_SERIAL_W_TO,
  ERROR_USB_IEP_BERR,
  ERROR_USB_IEP_PKTDRPSTS,
  ERROR_USB_IEP_BNA,
  ERROR_USB_IEP_TXFIFOUDRN,
  ERROR_USB_IEP_TOC,

  ERROR_USB_DSTS_IN_EERR,
  ERROR_USB_DSTS_OUT_EERR,

  ERROR_INTERPOL_ACCEL_MID_G,
  ERROR_INTERPOL_ACCEL_HIGH_G,
  ERROR_INTERPOL_GYRO,
  ERROR_INTERPOL_MAG,
  ERROR_INTERPOL_TEMPERATURE,
  ERROR_INTERPOL_PRESSURE,

  ERROR_BMA280_READ,
  ERROR_BMA280_FORCE_SAMPLE,
  ERROR_BMA280_SELF_TEST_FAIL,
  ERROR_GYRO_READ,
  ERROR_GYRO_FORCE_SAMPLE,
  ERROR_GYRO_REINIT,
  ERROR_GYRO_SELF_TEST_FAIL,
  ERROR_HMC5883L_READ,
  ERROR_MAG_INT_RECOVER,
  ERROR_MAG_BUS_RECOVER,
  ERROR_MAG_SELF_TEST_FAIL,
  ERROR_MAG_READ,
  ERROR_BMP280_READ,
  ERROR_ADXL375_READ,
  ERROR_ADXL_FORCE_SAMPLE,
  ERROR_ADXL375_INIT_FAIL,
  ERROR_ADXL375_SELF_TEST_FAIL,

  ERROR_MISSED_SAMPLE_BMA280,
  ERROR_MISSED_SAMPLE_ADXL375,
  ERROR_MISSED_SAMPLE_MAX21000,
  ERROR_MISSED_SAMPLE_MAG,
  ERROR_MISSED_SAMPLE_BMP280,

  ERROR_MAX_SAMPLE_WEIGHTS_EXCEDDED,

  ERROR_BQ24158_READ,
  ERROR_BQ24158_WRITE,
  ERROR_BQ24158_PART_ID,
  ERROR_BQ24158_WDT_RST_FAIL,

  ERROR_BQ27742_WRITE,
  ERROR_BQ27742_WRITEREAD,
  ERROR_BQ27742_PART_ID,

  ERROR_SPI1_RESET,
  ERROR_SPI2_RESET,
  ERROR_SPI3_RESET,
  ERROR_I2C3_SENSOR_NOT_READY,
  ERROR_I2C3_SENSOR_RESET,
  ERROR_I2C3_SENSOR_RESET_FAIL,
  ERROR_I2C2_SYSTEM_NOT_READY,
  ERROR_I2C2_SYSTEM_RESET,
  ERROR_I2C2_SYSTEM_RESET_FAIL,
  ERROR_CAN1_RESET,
  ERROR_USB_RESET,
  ERROR_SD_RESET,

  ERROR_QUEUE_ZERO_TIME_THRESHOLD,

  ERROR_RADIO_TX,
  ERROR_RADIO_RX,
  ERROR_RADIO_BUSY_WAIT_TIMEOUT,
  ERROR_RADIO_BUSY_TIMEOUT,
  ERROR_RADIO_CRC_RESPONSE,

  ERROR_RADIO_RESPONSE_BUSY,
  ERROR_RADIO_RESPONSE_BOOTLODER,
  ERROR_RADIO_RESPONSE_FIRMWARE,
  ERROR_RADIO_RESPONSE_CRC,
  ERROR_RADIO_RESPONSE_CMD,
  ERROR_RADIO_RESPONSE_DATA,
  ERROR_RADIO_RESPONSE_LENGTH,
  ERROR_RADIO_RESPONSE_MODE,
  ERROR_RADIO_RESPONSE_FULL,
  ERROR_RADIO_RESPONSE_EMPTY,
  ERROR_RADIO_RESPONSE_TIMEOUT,
  ERROR_RADIO_RESPONSE_NOP,
  ERROR_RADIO_RESPONSE_EXEC,
  ERROR_RADIO_RESPONSE_SYSTEM,

  ERROR_RADIO_CMD_STATUS,
  ERROR_RADIO_CMD_BOOTLOADER_VERSION,
  ERROR_RADIO_CMD_BOOTLOADER_READ_MEM,
  ERROR_RADIO_CMD_BOOTLOADER_READ_MEM4,
  ERROR_RADIO_CMD_BOOTLOADER_WRITE_MEM,
  ERROR_RADIO_CMD_BOOTLOADER_WRITE_MEM4,
  ERROR_RADIO_CMD_BOOTLOADER_ERASE_FLASH_PAGE,
  ERROR_RADIO_CMD_BOOTLOADER_WRITE_FLASH_PAGE,
  ERROR_RADIO_CMD_BOOTLOADER_FLASH_PAGE_SIZE,
  ERROR_RADIO_CMD_BOOTLOADER_FLASH_PAGE_BUFFER,
  ERROR_RADIO_CMD_BOOTLOADER_FIRMWARE_BASE,
  ERROR_RADIO_CMD_BOOTLOADER_CRC32,
  ERROR_RADIO_CMD_PROTOCOL_VERSION,
  ERROR_RADIO_CMD_SET_REGISTER,
  ERROR_RADIO_CMD_GET_REGISTER,
  ERROR_RADIO_CMD_TX_PACKET,
  ERROR_RADIO_CMD_RX_PACKET,
  ERROR_RADIO_CMD_DEBUG_COUNT,

  ERROR_RADIO_SET_REG_TX_MASK,
  ERROR_RADIO_SET_REG_FIFO_FLUSH,
  ERROR_RADIO_SET_REG_DEVICE_ID,
  ERROR_RADIO_SET_REG_MESH_CHANNEL,
  ERROR_RADIO_SET_REG_STREAMING_CHANNEL,
  ERROR_RADIO_SET_REG_BASIC_CHANNEL,
  ERROR_RADIO_SET_REG_LISTEN_CHANNEL,
  ERROR_RADIO_SET_REG_MESH_NODE_COUNT,
  ERROR_RADIO_SET_REG_GROUP_CODE,
  ERROR_RADIO_SET_REG_STREAMING_TX_MASK,
  ERROR_RADIO_SET_REG_INTERRUPT_MASK_,
  ERROR_RADIO_SET_REG_INTERRUPT_MASK_0,
  ERROR_RADIO_SET_REG_INTERRUPT_MASK_1,
  ERROR_RADIO_SET_REG_INTERRUPT_MASK_2,
  ERROR_RADIO_SET_REG_INTERRUPT_MASK_3,
  ERROR_RADIO_SET_REG_INTERRUPT_MASK_4,
  ERROR_RADIO_SET_REG_INTERRUPT_MASK_5,

  ERROR_RADIO_MESH_DATA_READ,

  ERROR_NRF_DUP_RX,
  ERROR_RADIO_DUP_RX,
  ERROR_RADIO_DUP_TX,
  ERROR_RADIO_STATE_TX,
  ERROR_RADIO_TX_PAYLOAD_TOO_LARGE,
  ERROR_RADIO_PROTO_VER_MISMATCH,
  ERROR_RADIO_RECONFIG,
  ERROR_RADIO_RX_FIFO_FULL,
  ERROR_RADIO_TX_FIFO_FULL,

  ERROR_STREAM_MIN_SYNC,
  ERROR_LATENCY_DISCARD,
  ERROR_RAW_OLD_DISCARD,
  ERROR_RECALC_NEXT_SYNC,


  ERROR_SYNC_STM_OUT_OF_SYNC,
  ERROR_UNKNOWN_QUEUE_TYPE,
  ERROR_FILT_RAW_Q_TOO_SHORT,
  ERROR_FILT_MAX_QUEUE_LENGTH,
  ERROR_BAD_RAW_TIME,

  ERROR_RADIO_RX_INV_GROUP,

  ERROR_FL_ERASE_FAIL,
  ERROR_FL_ERASE_BF,
  ERROR_FL_ERASE_NP,
  ERROR_FL_WRITE_FAIL,
  ERROR_SKIP_DATA,
  ERROR_ENQ_FAIL,
  ERROR_EMMC_REC_WR_FAIL,
  ERROR_EMMC_REC_NO_WRITE,
  ERROR_NEG_SYNC_JUMP,
  ERROR_RADIO_RX_FIFO_OFLOW,

  ERROR_EMMC_FILE_DEL_FAIL,
  ERROR_EMMC_DIR_CLOSE_FAIL,

  ERROR_USART_SPI_INIT,

  ERROR_DOUBLE_MISSED_SAMPLE,

  ERROR_BMA28X_ZERO_READING,
  ERROR_BMP280_ZERO_READING,
  ERROR_ADXL375_ZERO_READING,
  ERROR_GYRO_ZERO_READING,
  ERROR_MAG_ZERO_READING,

  ERROR_EMMC_RD_DATA_GAP,
  ERROR_TX_DATA_GAP,
  ERROR_RX_DATA_GAP,
  ERROR_USB_TX_DATA_GAP,

  ERROR_RNG_BUFF_OFLO,


  ERROR_Q_OVRR_FSD,
  ERROR_Q_OVRR_RAW_ACCEL_MID_G,
  ERROR_Q_OVRR_RAW_ACCEL_HIGH_G,
  ERROR_Q_OVRR_RAW_GYRO,
  ERROR_Q_OVRR_RAW_MAG,
  ERROR_Q_OVRR_RAW_TEMPERATURE,
  ERROR_Q_OVRR_RAW_PRESSURE,
  ERROR_Q_OVRR_RAW_RANGE,
  ERROR_Q_OVRR_RAW_HUMIDTY,
  ERROR_Q_OVRR_RAW,
  ERROR_Q_OVRR_SI,
  ERROR_Q_OVRR_SDO,
  ERROR_Q_OVRR_WIR_PKT,

  ERROR_NONFIN_FILT_BMA280,
  ERROR_NONFIN_FILT_BMP280,
  ERROR_NONFIN_FILT_FUSED,
  ERROR_NONFIN_FILT_ADXL375,
  ERROR_NONFIN_FILT_MAX21000,
  ERROR_NONFIN_FILT_HMC5883L,

  ERROR_NONFIN_AP_USB,

  ERROR_EMMC_WR_PROTECT,
  ERROR_EMMC_RW_ERR_R,
  ERROR_EMMC_RW_ERR_W,
  ERROR_EMMC_RW_ERR_O,
  ERROR_EMMC_NOT_READY_R,
  ERROR_EMMC_NOT_READY_W,
  ERROR_EMMC_NOT_READY_O,
  ERROR_EMMC_INV_PARAM_R,
  ERROR_EMMC_INV_PARAM_W,
  ERROR_EMMC_INV_PARAM_I,
  ERROR_EMMC_INV_PARAM_O,

  ERROR_FF_STRM_WRITE,
  ERROR_FF_STRM_READ,
  ERROR_FF_STRM_PUT,
  ERROR_FF_STRM_GET,

  ERROR_CAN_RDY_RESET,
  ERROR_CAN_RDY_TIMEOUT,
  ERROR_CAN_ERR_OTHER,

  ERROR_Q_OVRR_CAN_RX,
  ERROR_SYNCBOX_PROTO_ERR,

  ERROR_FILTER_NSYNC_ZERO,
  ERROR_FILTER_ZERO_WEIGHTS,

  ERROR_Q_OVRR_COMPRESSED,

  ERROR_CAN_TX_PENDING,
  ERROR_SYNC_NOT_CONNECTED,
  ERROR_FULL_SENSOR_INIT_RETRY,

  ERROR_INTERPOL_SX_ACCEL_MID_G,
  ERROR_INTERPOL_SX_ACCEL_HIGH_G,
  ERROR_INTERPOL_SX_GYRO,
  ERROR_INTERPOL_SX_MAG,
  ERROR_INTERPOL_SX_TEMPERATURE,

  ERROR_Q_OVRR_RAW_SX_ACCEL_MID_G,
  ERROR_Q_OVRR_RAW_SX_ACCEL_HIGH_G,
  ERROR_Q_OVRR_RAW_SX_GYRO,
  ERROR_Q_OVRR_RAW_SX_MAG,
  ERROR_Q_OVRR_RAW_SX_TEMPERATURE,

  ERROR_FILTER_Z_WINDOW,
  ERROR_EXTIO_SENSOR_TIME_GAP,
  ERROR_EXTIO_INTERPOL_BMA,
  ERROR_EXTIO_INTERPOL_ADXL,
  ERROR_EXTIO_INTERPOL_MAX,
  ERROR_EXTIO_INTERPOL_HMC,
  ERROR_BUTTON_1_PRESS,
  ERROR_BUTTON_2_PRESS,

  ERROR_EMMC_RD_RETRY_SUCCESS,
  ERROR_EMMC_WR_RETRY_SUCCESS,
  ERROR_EMMC_DATA_BOUNDRY,
  ERROR_INV_COMPRESSED_DATA,

  ERROR_BATTERY_GENERAL,
  ERROR_BQ27_GENERAL,
  ERROR_EMMC_GENERAL,

  ERROR_RF_SYS_ERROR_STACK_OVERFLOW,
  ERROR_RF_SYS_ERROR_WDT_EVENT,
  ERROR_RF_SYS_ERROR_POWER_EVENT,
  ERROR_RF_SYS_ERROR_CLOCK_EVENT,
  ERROR_RF_SYS_ERROR_SOFTDEVICE_EVENT,
  ERROR_RF_SYS_ERROR_OVERFLOW_EVENT,
  ERROR_RF_SYS_ERROR_RESET_EVENT,

#if defined SMART_SOX
  ERROR_SSOX_INSIDE_OUT,
  ERROR_SSOX_INIT_FAIL,
  ERROR_SSOX_CAN_QUEUES,
#endif

  ERROR_MAX_EVENT_ELEMENT
} monitor_events_t;


#define ERROR_MAX_ERROR_ELEMENT    ERROR_MAX_EVENT_ELEMENT

/**
 * Error states that are persistantly asserted (or de-asserted) during operation.
 */
typedef enum {
  ERROR_STATE_BMA28X = 0,
  ERROR_STATE_BMP280,
  ERROR_STATE_GYRO,
  ERROR_STATE_MAG,
  ERROR_STATE_ADXL375,

  ERROR_STATE_BQ24158,
  ERROR_STATE_BQ24158_WDT_RST_FAIL,
  ERROR_STATE_BQ27742,
  ERROR_STATE_BQ27742_NOT_FLASHED, //8
  ERROR_STATE_BQ27742_NOT_CALLIBRATED,
  ERROR_STATE_BQ27742_RECAL,
  ERROR_STATE_BQ27742_IT_DISABLED,
  ERROR_STATE_BQ27742_IT_NOT_LEARN,

  ERROR_STATE_BATTERY_SWELL,

  ERROR_STATE_NRF_FAIL,
  ERROR_STATE_NRF_NO_BOOTLOADER,
  ERROR_STATE_NRF_HARD_FAULT, //16
  ERROR_STATE_RF_QUEUE_BACKLOG,
  ERROR_STATE_RF_PROTO_MISMATCH,
  ERROR_STATE_RF_SYS_ERROR,
  ERROR_STATE_RF_SETUP,
  ERROR_STATE_RF_NO_TX_MASK,
  ERROR_STATE_RF_INVALID_RADIO_MODE,
  ERROR_STATE_RF_NO_TARGET_AP_ID,

  ERROR_STATE_RF_PKT_TOO_LARGE,

  ERROR_STATE_I2C2_SYSTEM,
  ERROR_STATE_I2C3_SENSOR,

  ERROR_STATE_NO_CAL_DATA,
  ERROR_STATE_CAL_DATA_MISMATCH,
  ERROR_STATE_FULL_FILESYSTEM,
  ERROR_STATE_MSD_DISABLED,
  ERROR_STATE_EMMC_FAIL,
  ERROR_STATE_FLUSH_CONFIG_FAIL,
  ERROR_STATE_FS_MOUNT_FAIL,
  ERROR_STATE_DATA_WRITE_FAIL,
  ERROR_STATE_FILE_INIT_FAIL,

  ERROR_STATE_INI_CONFIG_INVALID,

  ERROR_STATE_STK_OVERFLOW,

  ERROR_STATE_CONFIG_STRUCTURE_INVALID,

  ERROR_STATE_SHORTED_PINS,
  ERROR_STATE_PIN_PWR_DRAW,

  ERROR_STATE_USB_HW,//Usually due to a problem with the ULPI chip soldering.

  ERROR_STATE_INVALID_CAL_FILE,

  ERROR_STATE_BQ27742_TEMPERATURE,

  ERROR_STATE_FL_WR_ADDR,

  ERROR_STATE_DATA_STRUCTURE,
  ERROR_STATE_INVALID_TIMEZONE,
  ERROR_STATE_WIRELESS_SKIP_DATA,
  ERROR_STATE_NOT_MESHED,
  ERROR_STATE_NOT_TXING,
  ERROR_STATE_RNG_BUFF_FULL,
  ERROR_STATE_NEG_SYNC_JUMP,
  ERROR_STATE_BATTERY_FAULT,
  ERROR_STATE_BATTERY_NOT_CHARGING,
  ERROR_STATE_AP_NOT_VISIBLE,
  ERROR_STATE_RX_FIFO_OFLOW,
  ERROR_STATE_RX_UNEXPECTED,

  ERROR_STATE_RANGING_CONFIG,
  ERROR_STATE_RANGING_INIT,
  ERROR_STATE_DW_CONF,
  ERROR_STATE_USART_SPI_INIT,

  ERROR_STATE_LOGGING_DISABLED,
  ERROR_STATE_NO_SENSORS_ENABLED,

  ERROR_STATE_BMA28X_ZERO_READINGS,
  ERROR_STATE_BMP280_ZERO_READINGS,
  ERROR_STATE_ADXL375_ZERO_READINGS,
  ERROR_STATE_GYRO_ZERO_READINGS,
  ERROR_STATE_MAG_ZERO_READINGS,

  ERROR_STATE_BMA28X_FRC_READ,
  ERROR_STATE_ADXL375_FRC_READ,
  ERROR_STATE_GYRO_FRC_READ,
  ERROR_STATE_AP_BACKLOGGING,

  ERROR_STATE_FATFS_ERS,
  ERROR_STATE_EMMC_ERS,

  ERROR_STATE_INVALID_CAL_DATA,
  ERROR_STATE_INVALID_USER_CAL_DATA,

  ERROR_STATE_FILTER_SAMPLES_ZERO,
  ERROR_STATE_FILTER_PARAMS,
  ERROR_STATE_FILTER_INTERACTION,

  ERROR_STATE_FILTER_ERS,
  ERROR_STATE_EXTIO_GAP_ERS,

  ERROR_STATE_OPAL_TEMPERATURE,
  ERROR_STATE_NO_FILT_OUTPUT,
  ERROR_STATE_FLASH_SETTINGS,

  ERROR_STATE_DIRTY_FILESYSTEM,
  ERROR_STATE_CLOCK_NOT_SET,

  ERROR_STATE_SSOX_HEARTBEAT,

  ERROR_STATE_PIPELINE_INIT_FAIL,
  ERROR_STATE_BQ27742_CAPACITY,
  ERROR_STATE_UNSUPPORTED_PCB,

  ERROR_STATE_BQ27742_NO_COMM,

  ERROR_STATE_USER_CAL_DATA_MISMATCH,
  ERROR_STATE_BATTERY_SOH_LOW,

  ERROR_STATE_LAST
} monitor_state_t;


typedef enum {
  MONITOR_ERROR_CLASSIFICATION_NONE = 0,
  MONITOR_ERROR_CLASSIFICATION_HARDWARE,
  MONITOR_ERROR_CLASSIFICATION_FIRMWARE,
} monitor_error_classification_t;


/**
 *  This will map to a bit field to be passed from the sensor head to the monitor
 *  32 bit max
 */
typedef enum {
  SSOX_PACKED_STATUS_HEARTBEAT = 0,
  SSOX_PACKED_STATUS_ACCEL_HIGH_INIT,
  SSOX_PACKED_STATUS_ACCEL_MID_INIT,
  SSOX_PACKED_STATUS_GYRO_INIT,
  SSOX_PACKED_STATUS_MAG_INIT,
  SSOX_PACKED_STATUS_CAN_INIT,
  SSOX_PACKED_STATUS_I2C_ERROR,
  SSOX_PACKED_STATUS_SPI1_ERROR,
  SSOX_PACKED_STATUS_SPI2_ERROR,
  SSOX_PACKED_STATUS_ACCEL_HIGH_ERROR,
  SSOX_PACKED_STATUS_ACCEL_MID_ERROR,
  SSOX_PACKED_STATUS_GYRO_ERROR,
  SSOX_PACKED_STATUS_MAG_ERROR,
  SSOX_PACKED_STATUS_CAN_ERROR,
} ssox_packed_status_t;


/**
 * Paypload types when transfering data to the host libraries via USB.
 */
typedef enum {
  USB_PAYLOAD_TYPE_UNUSED = 0,
  USB_PAYLOAD_TYPE_SENSOR_SAMPLE,
  USB_PAYLOAD_TYPE_AP_STATS,
  USB_PAYLOAD_TYPE_GENERIC_WIRELESS_PACKET,
  USB_PAYLOAD_TYPE_AP_EVENT_COUNT,
  USB_PAYLOAD_TYPE_AP_ERROR_STATE,
  USB_PAYLOAD_TYPE_SYNC_BOX_DATA,
  USB_PAYLOAD_TYPE_COMPRESSED_SENSOR_SAMPLE,
  USB_PAYLOAD_TYPE_AP_SENSOR_STATUS_DATA,

  USB_PAYLOAD_TYPE_LAST_ELEMENT
} apdm_data_payload_type_t;




/**
 * Types of sensors supported.
 */
typedef enum {
  SENSOR_TYPE_NONE = 0,
  SENSOR_TYPE_BMA28X,
  SENSOR_TYPE_ADXL375,
  SENSOR_TYPE_GYRO,
  SENSOR_TYPE_MAG5883,
  SENSOR_TYPE_BMP280,
  SENSOR_TYPE_DW1000,

  SENSOR_TYPE_END_ELEMENT
} sensor_type_t;


/**
 * Types of queue data tracked in the firmware.
 */
typedef enum {
  QUEUE_TYPE_ACCEL_MID_G = 0,
  QUEUE_TYPE_ACCEL_HIGH_G,
  QUEUE_TYPE_GYRO,
  QUEUE_TYPE_MAG,
  QUEUE_TYPE_TEMPERATURE,
  QUEUE_TYPE_PRESSURE,

#if USE_SMART_SOX_BUFFERS
  QUEUE_TYPE_SX_ACCEL_MID_G,
  QUEUE_TYPE_SX_ACCEL_HIGH_G,
  QUEUE_TYPE_SX_GYRO,
  QUEUE_TYPE_SX_MAG,
#if USE_SMART_SOX_BUFFERS_TEMPERATURE
  QUEUE_TYPE_SX_TEMPERATURE,
#endif
#endif

  QUEUE_TYPE_COUNT_END_ELEMENT,
} queue_type_t;
//TODO rename this typedef to raw_queue_type_t


/**
 * Structucre type indicators while reading data from .APDM file on the fat file system.
 */
typedef enum {
  SD_STRUCTURE_TYPE_PADDING = 0,
  SD_STRUCTURE_TYPE_FILE_HEADER,
  SD_STRUCTURE_TYPE_DATA,
  SD_STRUCTURE_TYPE_ERROR_STATE,
  SD_STRUCTURE_TYPE_ERROR_EVENT,
  SD_STRUCTURE_TYPE_CALIBRATION_DATA,
  SD_STRUCTURE_TYPE_CONFIG_VALUE,
  SD_STRUCTURE_TYPE_DATA_RAW,
  SD_STRUCTURE_TYPE_DATA_SI, //8
  SD_STRUCTURE_TYPE_STRING,
  SD_STRUCTURE_TYPE_METRICS,
  SD_STRUCTURE_TYPE_BUTTON_PRESS,
  SD_STRUCTURE_TYPE_DATA_RANGE,
  SD_STRUCTURE_TYPE_DATA_COMPRESSED, //13
  SD_STRUCTURE_TYPE_LAST_BUTTON_PRESS_OFFSET,

  SD_STRUCTURE_TYPE_LAST_ELEMENT
} sd_structure_type_t;


typedef enum {
  SENSOR_READING_TYPE_NONE = 0,
  SENSOR_READING_TYPE_BMA28X_ACCEL,
  SENSOR_READING_TYPE_BMA28X_TEMPERATURE,
  SENSOR_READING_TYPE_ADXL375_ACCEL,
  SENSOR_READING_TYPE_MAX21000_GYRO,
  SENSOR_READING_TYPE_MAG5883_MAG,
  SENSOR_READING_TYPE_BMP280_PRESSURE,
  SENSOR_READING_TYPE_BMP280_TEMPERATURE,

  SENSOR_READING_TYPE_FUSED_ACCEL,
  SENSOR_READING_TYPE_DW1000_RANGE,

#if USE_SMART_SOX_BUFFERS
  SENSOR_READING_TYPE_SX_BMA28X_ACCEL,
  SENSOR_READING_TYPE_SX_ADXL375_ACCEL,
  SENSOR_READING_TYPE_SX_MAX21000_GYRO,
  SENSOR_READING_TYPE_SX_HMC5883L_MAG,
  SENSOR_READING_TYPE_SX_FUSED_ACCEL,
  SENSOR_READING_TYPE_SX_BMA28X_TEMPERATURE,
#endif

  SENSOR_READING_TYPE_LAST_ELEMENT
} sensor_reading_type_t;

#if 0
#if USE_SMART_SOX_BUFFERS
#  define SENSOR_READING_TYPE_LAST_ELEMENT    (SENSOR_READING_TYPE_SX_BMA28X_TEMPERATURE + 1)
#else
#  define SENSOR_READING_TYPE_LAST_ELEMENT    (SENSOR_READING_TYPE_DW1000_RANGE + 1)
#endif
#endif


typedef enum {
  SI_QUEUE_TYPE_ACCEL_MID_G,
  SI_QUEUE_TYPE_ACCEL_HIGH_G,
  SI_QUEUE_TYPE_GYRO,
  SI_QUEUE_TYPE_MAG,
  SI_QUEUE_TYPE_TEMPERATURE,
  SI_QUEUE_TYPE_PRESSURE,

  SI_QUEUE_TYPE_ACCEL_FUSED,

#if USE_SMART_SOX_BUFFERS
  SI_QUEUE_TYPE_SX_ACCEL_MID_G,
  SI_QUEUE_TYPE_SX_ACCEL_HIGH_G,
  SI_QUEUE_TYPE_SX_GYRO,
  SI_QUEUE_TYPE_SX_MAG,
  SI_QUEUE_TYPE_SX_ACCEL_FUSED,
  SI_QUEUE_TYPE_SX_TEMPERATURE,
#endif

  SI_QUEUE_TYPE_LAST_ELEMENT
} si_queue_type_t;

typedef enum {
  OUTPUT_CLASS_ACCEL = 0,
  OUTPUT_CLASS_ACCEL_MID,
  OUTPUT_CLASS_ACCEL_HIGH,
  OUTPUT_CLASS_GYRO,
  OUTPUT_CLASS_MAG,
  OUTPUT_CLASS_TEMPERATURE,
  OUTPUT_CLASS_PRESSURE,
  OUTPUT_CLASS_RANGE,

#if USE_SMART_SOX_BUFFERS
  OUTPUT_CLASS_SX_ACCEL,
  OUTPUT_CLASS_SX_ACCEL_MID,
  OUTPUT_CLASS_SX_ACCEL_HIGH,
  OUTPUT_CLASS_SX_GYRO,
  OUTPUT_CLASS_SX_MAG,
#endif

  OUTPUT_CLASS_LAST_ELEMENT2
} si_output_sensor_class_t;


typedef enum {
  SD_METRIC_WIRELESS = 0,
  SD_METRIC_WIRELESS_MESH,
  SD_METRIC_BATTERY
} sd_card_metric_type_t;

typedef enum {
  SD_STRING_VALUE_CONFIG_V2_STRING = 0,
  SD_STRING_VALUE_CASE_ID,
  SD_STRING_VALUE_FIRMWARE_VERSION,
  SD_STRING_VALUE_SENSOR_ID,
  SD_STRING_VALUE_HARDWARE_ID
} sd_card_string_value_type_t;


typedef enum {
  WIRELESS_PACKET_PAYLOAD_TYPE_NONE = 0,
  WIRELESS_PACKET_PAYLOAD_TYPE_DATA,

  WIRELESS_PACKET_PAYLOAD_TYPE_ERROR_COUNTS,
  WIRELESS_PACKET_PAYLOAD_TYPE_ERROR_STATES,
  WIRELESS_PACKET_PAYLOAD_TYPE_STATISTICS,
  WIRELESS_PACKET_PAYLOAD_CONFIG_SET,
  WIRELESS_PACKET_PAYLOAD_COMMAND_ACTION,
  WIRELESS_PACKET_PAYLOAD_CONFIG_VALUE,
  WIRELESS_PACKET_PAYLOAD_LABEL_STRING,
  WIRELESS_PACKET_PAYLOAD_RANGES,
  WIRELESS_PACKET_PAYLOAD_TYPE_DELTA_ENCODED_DATA,
  WIRELESS_PACKET_PAYLOAD_BUTTON_EVENT,

  WIRELESS_PACKET_PAYLOAD_TYPE_LAST_ELEMENT
} wireless_packet_payload_type_t;

typedef enum {
  WIRELESS_COMMAND_ACTION_NONE,
  WIRELESS_COMMAND_ACTION_APPLY_NEW_CONFIG,
  WIRELESS_COMMAND_ACTION_SET_MIN_SYNC_VALUE
} wireless_command_action_type_t;


typedef enum {
  WIRELESS_MESH_DATA_TYPE_NONE = 0,
  WIRELESS_MESH_DATA_TYPE_MINIMUM_SYNC,
  WIRELESS_MESH_DATA_TYPE_MAX_LATENCY_MS,
  WIRELESS_MESH_DATA_TYPE_POWER_OFF_OPAL,
  WIRELESS_MESH_DATA_TYPE_EPOCH_SECOND,
} wireless_mesh_data_type_t;


typedef enum {
  CONFIG_PACKED_8BIT_V2_ENABLE_ACCEL,
  CONFIG_PACKED_8BIT_V2_ENABLE_GYRO,
  CONFIG_PACKED_8BIT_V2_ENABLE_MAG,
  CONFIG_PACKED_8BIT_V2_ENABLE_PRESSURE,
  CONFIG_PACKED_8BIT_V2_FILE_FORMAT,
  CONFIG_PACKED_8BIT_V2_ENABLE_SI_SD_DATA_LOGGING,
  CONFIG_PACKED_8BIT_V2_ENABLE_RAW_SD_DATA_LOGGING,
  CONFIG_PACKED_8BIT_V2_WIRELESS_PROTOCOL,
  CONFIG_PACKED_8BIT_V2_WIRELESS_CHANNEL,
  CONFIG_PACKED_8BIT_V2_WIRELESS_TX_POWER,
  CONFIG_PACKED_8BIT_V2_FILTER_MODE,
  CONFIG_PACKED_8BIT_V2_SD_CARD_BUFFERING,
  CONFIG_PACKED_8BIT_V2_BATTERY_CUTOFF,
  CONFIG_PACKED_8BIT_V2_LED_MODE,
  CONFIG_PACKED_8BIT_V2_BUTTON_MODE,
  CONFIG_PACKED_8BIT_V2_EXTERNAL_COMMUNICATIONS_MODE, //Values from external_communications_mode_t
  CONFIG_PACKED_8BIT_V2_LCD_DISPLAY_ENABLE,
  CONFIG_PACKED_8BIT_V2_LCD_DISPLAY_ANGLE,
  CONFIG_PACKED_8BIT_V2_UNUSED,
  CONFIG_PACKED_8BIT_V2_DEBUG_LCD_ENABLE,
  CONFIG_PACKED_8BIT_V2_ENABLE_USB_CDC_ACM_VCOM,
  CONFIG_PACKED_8BIT_V2_ENABLE_AP_DATA_STREAMING,
  CONFIG_PACKED_8BIT_V2_UNUSED2,
  CONFIG_PACKED_8BIT_V2_UNUSED3,
  CONFIG_PACKED_8BIT_V2_UNUSED4,
  CONFIG_PACKED_8BIT_V2_DISABLE_CALIBRATION_DATA,
  CONFIG_PACKED_8BIT_V2_LOGGING_BEHAVIOR,
  CONFIG_PACKED_8BIT_V2_ENABLE_RANGING,
  CONFIG_PACKED_8BIT_V2_SENSOR_INDEX,
  CONFIG_PACKED_8BIT_V2_SENSOR_COUNT,
  CONFIG_PACKED_8BIT_V2_MOUNT_MODE,
  CONFIG_PACKED_8BIT_V2_WIRELESS_MESH_CHANNEL,
  CONFIG_PACKED_8BIT_V2_WIRELESS_DOCKING_BEHAVIOR,
  CONFIG_PACKED_8BIT_V2_STANDBY_MODE,
  CONFIG_PACKED_8BIT_V2_VALUE_LAST_ELEMENT,

  CONFIG_PACKED_8BIT_V2_LAST_8BIT_VALUE,

  CONFIG_PACKED_16BIT_V2_OUTPUT_RATE,
  CONFIG_PACKED_16BIT_V2_OUTPUT_RATE_WIRELESS_DIVIDER,
  CONFIG_PACKED_16BIT_V2_RAW_RATE_OVERRIDE_ACCEL_MID,
  CONFIG_PACKED_16BIT_V2_RAW_RATE_OVERRIDE_ACCEL_HIGH,
  CONFIG_PACKED_16BIT_V2_RAW_RATE_OVERRIDE_GYRO,
  CONFIG_PACKED_16BIT_V2_RAW_RATE_OVERRIDE_MAG,
  CONFIG_PACKED_16BIT_V2_RANGE_OVERRIDE_ACCEL_MID,
  CONFIG_PACKED_16BIT_V2_RANGE_OVERRIDE_GYRO,
  CONFIG_PACKED_16BIT_V2_RANGE_OVERRIDE_MAG,

  CONFIG_PACKED_16BIT_V2_LAST_16BIT_VALUE,

  CONFIG_PACKED_32BIT_V2_WIRELESS_LATENCY_MS,
  CONFIG_PACKED_32BIT_V2_WIRELESS_GROUP_CODE,
  CONFIG_PACKED_32BIT_V2_WIRELESS_TX_MASK,
  CONFIG_PACKED_32BIT_V2_WIRELESS_TARGET_AP_ID,
  CONFIG_PACKED_32BIT_V2_WIRELESS_DEBUG_CONTROL,
  CONFIG_PACKED_32BIT_V2_FILTER_MAX_LATENCY_MS,

  CONFIG_PACKED_32BIT_V2_LAST_32BIT_VALUE,
} config_v2_enum_packing_t;

typedef enum {
  MONITOR_PRODUCT_OPAL,
  MONITOR_PRODUCT_AP,

  MONITOR_PRODUCT_LAST_ELEMENT
} monitor_product_t;

typedef enum {
  ERROR_LEVEL_MINIMUM = 0,
  ERROR_LEVEL_WARNING,
  ERROR_LEVEL_CRITICAL
} error_level_t;

error_level_t error_log_get_error_level_from_state(const monitor_state_t s);

bool config_validate_data(void);
monitor_error_classification_t monitor_state_t_to_monitor_error_classification_t(const monitor_state_t v);
monitor_error_classification_t monitor_events_t_to_monitor_error_classification_t(const monitor_events_t v);

//======================================================================================
// Enum to string mappings
const char* error_level_t_to_str(const error_level_t e);

const char* apdm_data_payload_type_t_to_str(const apdm_data_payload_type_t v);
const char* apdm_device_data_t_to_str(const apdm_device_data_t v);
const char* apdm_device_statistic_t_to_str(const apdm_device_statistic_t v);
const char* apdm_device_statistic_t_to_str_long(const apdm_device_statistic_t v);
const char* apdm_sd_structure_type_t_to_str(const sd_structure_type_t v);
const char* apdm_si_output_sensor_class_t_to_user_str(const si_output_sensor_class_t v);
const char* apdm_si_output_sensor_class_t_to_user_str_short(const si_output_sensor_class_t v);
const char* apdm_si_queue_type_t_to_str(const si_queue_type_t v);
const char* apdm_queue_type_t_to_str(const queue_type_t v);
const char* apdm_queue_type_t_to_str_short(const queue_type_t v);
const char* button_event_t_to_str(const button_event_t v);
const char* calibration_type_t_to_str(const calibration_type_t v);
const char* can_cmd_types_t_to_str(const can_cmd_types_t v);
const char* can_edge_t_to_str(const can_edge_t arg);
const char* can_packet_status_t_to_str(const can_packet_status_t arg);
const char* can_set_cmd_t_to_str(const can_set_cmd_t arg);
const char* can_sync_box_pin_t_to_str(const can_sync_box_pin_t v);
const char* can_query_cmd_t_to_str(const can_query_cmd_t arg);
const char* config_v2_string_t_to_str(const config_v2_string_t v);
const char* config_v2_string_t_to_str_hint(const config_v2_string_t v);
const char* config_value_t_to_str(const config_value_t v);
const char* config_value_t_to_str_short(const config_value_t v);
const char* config_value_t_to_str_hint(const config_value_t v);
const char* external_sensor_type_t_to_str(const external_sensor_type_t v);
const char* hardware_id_t_to_str(const hardware_id_t rev);
const char* monitor_error_classification_t_to_str(const monitor_error_classification_t v);
const char* monitor_events_t_to_user_str(const monitor_events_t event);
const char* monitor_product_t_to_user_str(const monitor_product_t product);
const char* monitor_product_t_to_user_str_short(const monitor_product_t product);
const char* monitor_state_t_error_description(const monitor_state_t v);
const char* monitor_state_t_error_description_sort(const monitor_state_t v);
const char* monitor_state_t_to_user_str(const monitor_state_t es);
const char* sd_card_metric_type_t_to_str(const sd_card_metric_type_t v);
const char* sensor_reading_type_t_to_str(const sensor_reading_type_t v);
const char* sensor_reading_type_t_to_str_short(const sensor_reading_type_t v);
const char* sensor_type_t_to_user_str(const sensor_type_t sensor_type);
const char* sensor_type_t_to_str(const sensor_type_t sensor_type);
const char* wireless_mesh_data_type_t_to_str(const wireless_mesh_data_type_t v);
const char* wireless_v2_radio_mode_t_to_str(const wireless_v2_radio_mode_t mode);
const char* wireless_v2_radio_mode_t_to_str_short(const wireless_v2_radio_mode_t mode);
const char* wireless_v2_radio_mode_t_to_str_short_user(const wireless_v2_radio_mode_t mode);

//======================================================================================
// String to Enum mappings
apdm_device_data_t str_to_device_data_t(const char *str);
apdm_device_statistic_t str_to_apdm_device_statistic_t(const char *str);
can_query_cmd_t str_to_can_query_cmd_t(const char *buff);
can_set_cmd_t str_to_can_set_cmd_t(const char *buff);
config_value_t str_to_config_value_t(const char *str);
config_v2_string_t str_to_config_v2_string_t(const char *str);


#endif /* V2_COMMON_ENUMS_H_ */
